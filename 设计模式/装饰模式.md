## 装饰模式

- 模式定义

  > `装饰模式（Decorator Pattern）`是指创建一个装饰类，来包装原有的类，从而实现动态地向一个现有的对象添加一些额外的职责，同时不改变其原有的结构。`装饰模式`比生成子类更为灵活。



- 问题描述：

使用程序写一个可以给人搭配不同服饰的系统，譬如QQ、电商平台或者	游戏都有的Avatar系统，实现给人搭配嘻哈服或白领装的功能。

程序预期的输出效果如下图所示：

![image-20221215072229177](https://tva1.sinaimg.cn/large/008vxvgGgy1h94h4ofzagj31lu0g8gn1.jpg)

为实现这一程序，可先定义Person类，将服饰装扮都写为Person类的接口方法。但如若要在此基础上增加“超人”的装扮，就需要修改Person类，会违背开放-封闭原则，因此应考虑将服饰单独为类。

![image-20221215072413115](https://tva1.sinaimg.cn/large/008vxvgGgy1h94h6fin18j31lk09mdgp.jpg)

同时，由于穿衣过程不能在众目睽睽之下完成，应当考虑在类内部组装完毕，再显示。而类内部的服饰组装过程不是固定的，因为通过服饰组合出一个有个性的人完全可以有无数种方案，如上衣大T恤，既可以搭配球鞋，也可以搭配皮鞋。同时服饰的装扮的先后顺序也有一定讲究，毕竟先穿内裤后穿外裤和先穿外裤再穿内裤是截然不同的效果。也就是说，我们需要将所需功能按正确的顺序串联起来进行控制，此时可以考虑使用`装饰模式`。

- 问题分析

  `装饰模式`用在此问题较为直观，衣服、鞋子、领带、披风等服饰都可以理解为对人的装饰。在实现Person类表示人的基础上，定义具体的服饰类实现对Person类进行服装装饰，装扮完再统一显示，这样既避免了穿每一件衣服的过程直接在客户端实现，同时又保留服装搭配的灵活性。



## 模式实现

使用`装饰模式`来解决问题。

1. 创建抽象的接口类`Component`，定义给对象动态添加职责的公共接口（在此例中，由于具体的接口只有一个，所以该步也可省略）；

2. 创建具体的接口`Person`(Concrete Component)，继承于抽象接口类

   `Component`，同时：

   - 定义方法`Show()`用于显示装扮结果；

3. 创建抽象的装饰类

   `Finery`（Decorator），继承于接口类`Person`（一般来说继承于抽象接口类`Component`，由于此例只有一个接口，故继承于具体接口类），同时：

   - 定义方法`Decorate(component)`用于进行装扮过程；
   - 覆写`Show()`具体装扮结果的显示；

4. 创建系列具体的服饰类（Concrete Decorator），如`Tshirts`，`BigTrouser`等，继承于抽象装饰类`Finery`，实现具体的装饰对象，同时：

   - 覆写`Show()`具体装扮结果的显示。



## 代码实现

















