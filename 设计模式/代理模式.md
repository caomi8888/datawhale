## 代理模式

- 问题描述：

  隔壁班的卓贾易想追求娇娇，但是他自己不好意思，就委托和娇娇同班的戴励帮助他。卓贾易给娇娇先后买了芭比娃娃、花、巧克力，饼委托戴励送给娇娇，却没想给娇娇和戴励创造了相处的机会。娇娇和戴励通过接触互生情愫，最后在一起了。卓贾易自然是很生气，一番追求却为他人做了嫁衣。但细细想来，虽说一直是卓贾易给娇娇买的礼物，但娇娇自始至终都是从戴励手里拿到的礼物，她并未接触过送礼之人——卓贾易。

  现在我们想用程序来描述这一个故事，关键之处在于准确描述卓贾易、戴励及娇娇三者之间的行动关系。如果我们只描述了追求者卓贾易，和被追求者娇娇，则与实际情况不符，因为娇娇并不认识卓贾易；而若我们只描述了代理戴励，和被追求者娇娇，亦与实际情况不符，因为礼物是卓贾易买的，戴励并没有礼物直接送给娇娇。为了准确描述他们三人的关系，我们可以考虑使用`代理模式`。

- 模式定义：

  `代理模式（Proxy Pattern）`是指实现一个类代表另一个类的功能，为其他对象提供一种代理以控制对这个对象的访问。

- 问题分析：

  `代理模式（Proxy Pattern）`可以应用到这一问题中。

  这一问题中有三个类型的角色，追求者（卓贾易），代理（戴励）和被追求者（娇娇）。他们三者间的关系满足，追求者（卓贾易）委托代理（戴励），通过代理（戴励）给被追求者（娇娇）送礼物，而被追求者（娇娇）只与代理（戴励）有接触。

  若使用代理模式描述，即代理（戴励）代表了追求者（卓贾易）的追求（赠送礼物）的功能，被追求者（娇娇）仅与代理（戴励）接触便收到了礼物。这样就实现了他们三人关系的准确描述。

## 模式实现

- 解决方案

  使用`代理模式`来解决这一问题。

  1. 创建送礼物的抽象类

     `IGiveGift`，定义追求者和代理的共用接口：

     - 送玩具方法`GiveDolls()`;
     - 送花方法`GiveFlowers()`;
     - 送巧克力方法`GiveChocolate()`。

  2. 创建追求者

     `Pursuit`，定义需要代理的真正实体，继承于抽象类`IGiveGift`:

     - 覆写类初始化方法，记录被追求者姓名；
     - 覆写送玩具、送花、送巧克力方法，具体送礼操作。

  3. 创建代理`Proxy`，保存追求者实体的一个引用，使得代理可以访问实体，继承于抽象类`IGiveGift`，实现对实体的替代：

     - 覆写类初始化方法，初始化的同时初始化一个追求者`Pursuit`对象；
     - 覆写送玩具、送花、送巧克力方法，在每一个送礼方法下调用追求者`Pursuit`的具体送礼操作